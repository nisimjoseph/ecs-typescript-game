<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECS Architecture Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 2rem;
            text-align: center;
            border-bottom: 2px solid #00d9ff;
            box-shadow: 0 4px 20px rgba(0, 217, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5rem;
            color: #00d9ff;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
        }

        .header p {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .container {
            display: flex;
            height: calc(100vh - 180px);
        }

        .sidebar {
            width: 280px;
            background: rgba(0, 0, 0, 0.4);
            padding: 1.5rem;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .sidebar h2 {
            color: #00d9ff;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #444;
        }

        .nav-item {
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .nav-item:hover {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
            transform: translateX(5px);
        }

        .nav-item.active {
            background: rgba(0, 217, 255, 0.3);
            border-color: #00d9ff;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
        }

        .nav-item .title {
            font-weight: 600;
            color: #00d9ff;
            margin-bottom: 0.25rem;
        }

        .nav-item .subtitle {
            font-size: 0.8rem;
            color: #a0a0a0;
        }

        .content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        .diagram-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .diagram-container h2 {
            color: #00d9ff;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(0, 217, 255, 0.3);
        }

        .diagram-container h3 {
            color: #00d9ff;
            font-size: 1.3rem;
            margin: 1.5rem 0 1rem 0;
        }

        .diagram-container p {
            color: #b0b0b0;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .mermaid {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .hidden {
            display: none !important;
        }
        
        .rendering {
            position: absolute;
            left: -9999px;
            visibility: hidden;
        }

        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid #333;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 217, 255, 0.3);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 217, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ—ï¸ ECS Architecture Diagrams</h1>
        <p>Interactive visualization of the TypeScript ECS implementation</p>
    </div>

    <div class="container">
        <div class="sidebar">
            <h2>ğŸ“‹ Navigation</h2>
            <div class="nav-item active" onclick="showDiagram(0)">
                <div class="title">ğŸ“Š High-Level Overview</div>
                <div class="subtitle">System architecture overview</div>
            </div>
            <div class="nav-item" onclick="showDiagram(1)">
                <div class="title">ğŸŒ World Architecture</div>
                <div class="subtitle">World class structure</div>
            </div>
            <div class="nav-item" onclick="showDiagram(2)">
                <div class="title">ğŸ“¦ Storage: Archetypes</div>
                <div class="subtitle">Archetype system</div>
            </div>
            <div class="nav-item" onclick="showDiagram(3)">
                <div class="title">ğŸ“¦ Storage: Table</div>
                <div class="subtitle">Table storage detail</div>
            </div>
            <div class="nav-item" onclick="showDiagram(4)">
                <div class="title">ğŸ“¦ Storage: SparseSet</div>
                <div class="subtitle">SparseSet storage</div>
            </div>
            <div class="nav-item" onclick="showDiagram(5)">
                <div class="title">ğŸ” Query: Execution Flow</div>
                <div class="subtitle">Query execution process</div>
            </div>
            <div class="nav-item" onclick="showDiagram(6)">
                <div class="title">ğŸ” Query: Filter Types</div>
                <div class="subtitle">Query filter options</div>
            </div>
            <div class="nav-item" onclick="showDiagram(7)">
                <div class="title">ğŸ“¡ Events: Double-Buffered</div>
                <div class="subtitle">Event buffer system</div>
            </div>
            <div class="nav-item" onclick="showDiagram(8)">
                <div class="title">ğŸ“¡ Events: Flow</div>
                <div class="subtitle">Event flow in game</div>
            </div>
            <div class="nav-item" onclick="showDiagram(9)">
                <div class="title">ğŸ‘ï¸ Observers: Registration</div>
                <div class="subtitle">Observer registry</div>
            </div>
            <div class="nav-item" onclick="showDiagram(10)">
                <div class="title">ğŸ‘ï¸ Observers: Trigger Flow</div>
                <div class="subtitle">Observer execution</div>
            </div>
            <div class="nav-item" onclick="showDiagram(11)">
                <div class="title">ğŸ“¦ Bundles: Hierarchy</div>
                <div class="subtitle">Bundle inheritance</div>
            </div>
            <div class="nav-item" onclick="showDiagram(12)">
                <div class="title">ğŸ“¦ Bundles: Spawning</div>
                <div class="subtitle">Bundle spawn sequence</div>
            </div>
            <div class="nav-item" onclick="showDiagram(13)">
                <div class="title">âš™ï¸ Systems: Execution Order</div>
                <div class="subtitle">Stage execution timeline</div>
            </div>
            <div class="nav-item" onclick="showDiagram(14)">
                <div class="title">âš™ï¸ Systems: Dependencies</div>
                <div class="subtitle">System dependency graph</div>
            </div>
            <div class="nav-item" onclick="showDiagram(15)">
                <div class="title">ğŸ”„ Change Detection</div>
                <div class="subtitle">Tick-based tracking</div>
            </div>
            <div class="nav-item" onclick="showDiagram(16)">
                <div class="title">ğŸ® Game Loop</div>
                <div class="subtitle">Complete frame flow</div>
            </div>
        </div>

        <div class="content">
            <!-- Diagram 0: High-Level Overview -->
            <div class="diagram-container" id="diagram-0">
                <h2>ğŸ“Š High-Level Overview</h2>
                <p>This diagram shows the overall architecture of the ECS system, including user code, ECS framework, and internal systems.</p>
                <div class="mermaid">
graph TB
    subgraph "User Code"
        MAIN[main.ts]
        GSYS[Game Systems]
        GCOMP[Game Components]
        GBUND[Game Bundles]
        GEVT[Game Events]
        GOBS[Game Observers]
    end
    
    subgraph "ECS Framework"
        APP[App]
        WORLD[World]
        QUERY[Query]
        CMD[Commands]
    end
    
    subgraph "ECS Internals"
        ENTITY[Entity Allocator]
        COMP[Component Registry]
        ARCH[Archetypes]
        STORAGE[Storage Layer]
        EVENTS[Event System]
        OBSERVERS[Observer System]
    end
    
    MAIN --> APP
    GSYS --> APP
    GCOMP --> COMP
    GBUND --> WORLD
    GEVT --> EVENTS
    GOBS --> OBSERVERS
    
    APP --> WORLD
    WORLD --> ENTITY
    WORLD --> COMP
    WORLD --> EVENTS
    
    QUERY --> ARCH
    CMD --> WORLD
    
    COMP --> ARCH
    ARCH --> STORAGE
                </div>
            </div>

            <!-- Diagram 1: World Architecture -->
            <div class="diagram-container hidden" id="diagram-1">
                <h2>ğŸŒ World Architecture</h2>
                <p>The World is the central container for all ECS data.</p>
                <div class="mermaid">
classDiagram
    class World {
        -entityAllocator: EntityAllocator
        -componentRegistry: ComponentRegistry
        -resourceRegistry: ResourceRegistry
        -commands: Commands
        +spawn() EntityBuilder
        +despawn(entity) void
        +query(...types) Query
        +getResource(type) T
        +insertResource(resource) void
        +applyCommands() void
    }
    
    class EntityAllocator {
        -entities: Entity[]
        -freeList: number[]
        -nextId: number
        +allocate() Entity
        +deallocate(entity) void
        +isAlive(entity) boolean
    }
    
    class ComponentRegistry {
        -componentInfos: Map
        -archetypes: Archetypes
        +register(type) ComponentId
        +insert(entity, component) void
        +get(entity, type) T
        +remove(entity, type) void
    }
    
    class ResourceRegistry {
        -resources: Map
        +insert(resource) void
        +get(type) T
        +remove(type) void
    }
    
    class Commands {
        -queue: Command[]
        +spawn() EntityBuilder
        +despawn(entity) void
        +insert(entity, component) void
        +apply(world) void
    }
    
    World --> EntityAllocator
    World --> ComponentRegistry
    World --> ResourceRegistry
    World --> Commands
                </div>
            </div>

            <!-- Diagram 2: Archetype System -->
            <div class="diagram-container hidden" id="diagram-2">
                <h2>ğŸ“¦ Storage Architecture: Archetype System</h2>
                <p>Entities are grouped by their component layout into archetypes for efficient storage and querying.</p>
                <div class="mermaid">
graph LR
    subgraph arch0["Archetype 0"]
        A0_ID["ID: 0"]
        A0_COMP["Components: none"]
        A0_ENT["Entities: empty"]
    end
    
    subgraph arch1["Archetype 1"]
        A1_ID["ID: 1"]
        A1_COMP["Position, Velocity, Player"]
        A1_ENT["Entities: E0"]
        A1_TABLE["Table Storage"]
    end
    
    subgraph arch2["Archetype 2"]
        A2_ID["ID: 2"]
        A2_COMP["Position, Velocity, Enemy, Wander"]
        A2_ENT["Entities: E1, E2, E3"]
        A2_TABLE["Table Storage"]
    end
    
    A0_ID --> A1_ID
    A1_ID --> A2_ID
                </div>
            </div>

            <!-- Diagram 3: Table Storage -->
            <div class="diagram-container hidden" id="diagram-3">
                <h2>ğŸ“¦ Storage Architecture: Table Storage Detail</h2>
                <p>Table storage uses column-based layout for cache-efficient component access.</p>
                <div class="mermaid">
graph TB
    subgraph "Table for Archetype 2"
        COLS[Columns]
        
        subgraph "Position Column"
            P0["[0] {x: 100, y: 200}"]
            P1["[1] {x: 300, y: 150}"]
            P2["[2] {x: 450, y: 400}"]
        end
        
        subgraph "Velocity Column"
            V0["[0] {x: 10, y: 0}"]
            V1["[1] {x: -5, y: 5}"]
            V2["[2] {x: 0, y: 10}"]
        end
        
        subgraph "Entity Mapping"
            E1["Entity 1 â†’ Row 0"]
            E2["Entity 2 â†’ Row 1"]
            E3["Entity 3 â†’ Row 2"]
        end
    end
                </div>
            </div>

            <!-- Diagram 4: SparseSet Storage -->
            <div class="diagram-container hidden" id="diagram-4">
                <h2>ğŸ“¦ Storage Architecture: SparseSet Storage</h2>
                <p>SparseSet provides O(1) lookup for sparse components that aren't present on all entities.</p>
                <div class="mermaid">
graph TB
    subgraph "SparseSet"
        subgraph "Sparse Array (Entity â†’ Dense Index)"
            S0["[0] = 2"]
            S1["[1] = null"]
            S2["[2] = 0"]
            S3["[3] = 1"]
        end
        
        subgraph "Dense Array (Components)"
            D0["[0] = ComponentA"]
            D1["[1] = ComponentB"]
            D2["[2] = ComponentC"]
        end
        
        subgraph "Entity Array (Dense â†’ Entity)"
            E0["[0] = Entity 2"]
            E1["[1] = Entity 3"]
            E2["[2] = Entity 0"]
        end
    end
    
    S0 -.->|"Entity 0"| D2
    S2 -.->|"Entity 2"| D0
    S3 -.->|"Entity 3"| D1
                </div>
            </div>

            <!-- Diagram 5: Query Execution Flow -->
            <div class="diagram-container hidden" id="diagram-5">
                <h2>ğŸ” Query System: Execution Flow</h2>
                <p>Queries iterate through archetypes, matching components and applying filters.</p>
                <div class="mermaid">
flowchart TB
    START[Query Created]
    
    START --> MATCH[Match Archetypes]
    
    MATCH --> CHECK{Has All<br>Required Components?}
    
    CHECK -->|No| SKIP[Skip Archetype]
    CHECK -->|Yes| FILTER[Apply Filters]
    
    SKIP --> NEXT{More Archetypes?}
    
    FILTER --> WITH{With Filter<br>Passes?}
    WITH -->|No| SKIP
    WITH -->|Yes| WITHOUT{Without Filter<br>Passes?}
    
    WITHOUT -->|No| SKIP
    WITHOUT -->|Yes| CHANGE{Change Detection<br>Passes?}
    
    CHANGE -->|No| SKIP
    CHANGE -->|Yes| YIELD[Yield Entity + Components]
    
    YIELD --> NEXT
    NEXT -->|Yes| CHECK
    NEXT -->|No| END[Query Complete]
                </div>
            </div>

            <!-- Diagram 6: Query Filter Types -->
            <div class="diagram-container hidden" id="diagram-6">
                <h2>ğŸ” Query System: Filter Types</h2>
                <p>Query filters allow fine-grained control over which entities are returned.</p>
                <div class="mermaid">
graph TB
    subgraph "Query Filters"
        BASE["query(Position, Velocity)"]
        
        WITH[".with(Health)"]
        WITHOUT[".without(Dead)"]
        ADDED[".added(Enemy)"]
        CHANGED[".changed(Health)"]
    end
    
    BASE --> WITH
    BASE --> WITHOUT
    BASE --> ADDED
    BASE --> CHANGED
    
    subgraph "Result"
        RES[Filtered Entities]
    end
    
    WITH --> RES
    WITHOUT --> RES
    ADDED --> RES
    CHANGED --> RES
                </div>
            </div>

            <!-- Diagram 7: Double-Buffered Events -->
            <div class="diagram-container hidden" id="diagram-7">
                <h2>ğŸ“¡ Event System: Double-Buffered Events</h2>
                <p>Events use double buffering to prevent reading and writing to the same buffer simultaneously.</p>
                <div class="mermaid">
sequenceDiagram
    participant W as Writer
    participant B1 as Buffer A
    participant B2 as Buffer B
    participant R as Reader
    
    Note over B1,B2: Frame N: Buffer A is "write", Buffer B is "read"
    
    W->>B1: send(event1)
    W->>B1: send(event2)
    R->>B2: iter() â†’ []
    
    Note over B1,B2: End of Frame: Swap
    
    Note over B1,B2: Frame N+1: Buffer B is "write", Buffer A is "read"
    
    W->>B2: send(event3)
    R->>B1: iter() â†’ [event1, event2]
                </div>
            </div>

            <!-- Diagram 8: Event Flow -->
            <div class="diagram-container hidden" id="diagram-8">
                <h2>ğŸ“¡ Event System: Event Flow in Game</h2>
                <p>Events flow from collision detection through various processors.</p>
                <div class="mermaid">
flowchart LR
    subgraph "Collision Detection"
        CD[Collision System]
    end
    
    subgraph "Events"
        BE[BulletHitEvent]
        SE[ScoreEvent]
        KE[EntityKilledEvent]
    end
    
    subgraph "Event Processors"
        PS[Score System]
        LS[Logger]
        UI[UI Update]
    end
    
    CD -->|bullet hits enemy| BE
    BE -->|enemy died| SE
    BE -->|enemy died| KE
    
    SE --> PS
    BE --> LS
    KE --> LS
    SE --> UI
                </div>
            </div>

            <!-- Diagram 9: Observer Registration -->
            <div class="diagram-container hidden" id="diagram-9">
                <h2>ğŸ‘ï¸ Observer System: Observer Registration</h2>
                <p>Observers are registered to react to component lifecycle events.</p>
                <div class="mermaid">
graph TB
    subgraph "Observer Registry"
        REG[Registry]
        
        subgraph "OnAdd Observers"
            OA1["Player â†’ logSpawn"]
            OA2["Enemy â†’ logSpawn"]
            OA3["Bullet â†’ logSpawn"]
        end
        
        subgraph "OnChange Observers"
            OC1["Health â†’ checkDeath"]
            OC2["Position â†’ updateSpatial"]
        end
        
        subgraph "OnRemove Observers"
            OR1["Player â†’ gameOver"]
            OR2["Enemy â†’ updateScore"]
        end
    end
    
    REG --> OA1
    REG --> OA2
    REG --> OA3
    REG --> OC1
    REG --> OC2
    REG --> OR1
    REG --> OR2
                </div>
            </div>

            <!-- Diagram 10: Observer Trigger Flow -->
            <div class="diagram-container hidden" id="diagram-10">
                <h2>ğŸ‘ï¸ Observer System: Trigger Flow</h2>
                <p>When components are added/changed/removed, observers are automatically triggered.</p>
                <div class="mermaid">
sequenceDiagram
    participant S as System
    participant W as World
    participant OR as Observer Registry
    participant O as Observer Callback
    
    S->>W: spawn().insert(Enemy)
    W->>OR: trigger(OnAdd, entity, Enemy)
    OR->>O: Execute callback
    O->>O: Log "Enemy spawned"
    O->>O: Send EntitySpawnedEvent
                </div>
            </div>

            <!-- Diagram 11: Bundle Hierarchy -->
            <div class="diagram-container hidden" id="diagram-11">
                <h2>ğŸ“¦ Bundle System: Bundle Hierarchy</h2>
                <p>Bundles group components together and can inherit from base bundles.</p>
                <div class="mermaid">
graph TB
    subgraph "Bundle Interface"
        BI[Bundle]
    end
    
    subgraph "Game Bundles"
        PB[PlayerBundle]
        EB[EnemyBundle]
        BB[BulletBundle]
        PUB[PowerUpBundle]
    end
    
    subgraph "Enemy Variants"
        WEB[WanderingEnemyBundle]
        CEB[ChasingEnemyBundle]
    end
    
    BI --> PB
    BI --> EB
    BI --> BB
    BI --> PUB
    
    EB --> WEB
    EB --> CEB
                </div>
            </div>

            <!-- Diagram 12: Bundle Spawning -->
            <div class="diagram-container hidden" id="diagram-12">
                <h2>ğŸ“¦ Bundle System: Bundle Spawning</h2>
                <p>The sequence of spawning an entity using a bundle.</p>
                <div class="mermaid">
sequenceDiagram
    participant C as Code
    participant B as Bundle
    participant W as World
    participant EB as EntityBuilder
    participant CR as ComponentRegistry
    
    C->>B: new PlayerBundle(x, y)
    C->>B: components()
    B-->>C: [Position, Velocity, Health, ...]
    
    C->>W: spawn()
    W-->>C: EntityBuilder
    
    loop For each component
        C->>EB: insert(component)
        EB->>CR: register & store
    end
    
    C->>EB: id()
    EB-->>C: Entity
                </div>
            </div>

            <!-- Diagram 13: System Execution Order -->
            <div class="diagram-container hidden" id="diagram-13">
                <h2>âš™ï¸ System Scheduling: Stage Execution Order</h2>
                <p>Systems execute in stages, with each stage running all its systems before moving to the next.</p>
                <div class="mermaid">
gantt
    title System Execution Per Frame
    dateFormat X
    axisFormat %s
    
    section Stage.First
    inputClearSystem :a1, 0, 1
    
    section Stage.PreUpdate
    playerInputSystem :a2, 1, 2
    playerShootSystem :a3, 2, 3
    
    section Stage.Update
    wanderSystem :a4, 3, 4
    followTargetSystem :a5, 4, 5
    movementSystem :a6, 5, 6
    bounceSystem :a7, 6, 7
    trailSystem :a8, 7, 8
    
    section Stage.PostUpdate
    lifetimeSystem :a9, 8, 9
    explosionSystem :a10, 9, 10
    collisionSystem :a11, 10, 11
    processEventsSystem :a12, 11, 12
    enemySpawnSystem :a13, 12, 13
    
    section Stage.Last
    renderSystem :a14, 13, 14
    uiUpdateSystem :a15, 14, 15
    updateEventsSystem :a16, 15, 16
                </div>
            </div>

            <!-- Diagram 14: System Dependencies -->
            <div class="diagram-container hidden" id="diagram-14">
                <h2>âš™ï¸ System Scheduling: System Dependencies</h2>
                <p>Systems have implicit dependencies based on the data they read and write.</p>
                <div class="mermaid">
graph LR
    subgraph "Input"
        IC[inputClear]
        PI[playerInput]
        PS[playerShoot]
    end
    
    subgraph "AI"
        WS[wander]
        FT[followTarget]
    end
    
    subgraph "Physics"
        MS[movement]
        BS[bounce]
    end
    
    subgraph "Visuals"
        TS[trail]
        RS[render]
    end
    
    subgraph "Gameplay"
        LS[lifetime]
        CS[collision]
        ES[explosion]
    end
    
    IC --> PI
    PI --> PS
    PI --> MS
    
    WS --> MS
    FT --> MS
    
    MS --> BS
    MS --> TS
    
    BS --> CS
    TS --> RS
    
    CS --> ES
    LS --> CS
                </div>
            </div>

            <!-- Diagram 15: Change Detection -->
            <div class="diagram-container hidden" id="diagram-15">
                <h2>ğŸ”„ Change Detection: Tick-Based Tracking</h2>
                <p>Components track when they were added and changed using world ticks.</p>
                <div class="mermaid">
graph TB
    subgraph "World Ticks"
        T1["Tick 1: Initial spawn"]
        T5["Tick 5: Health modified"]
        T10["Tick 10: Query runs"]
    end
    
    subgraph "Component Ticks"
        CT["Health Component"]
        ADDED["added_tick: 1"]
        CHANGED["changed_tick: 5"]
    end
    
    subgraph "System State"
        SS["Last Run Tick: 3"]
    end
    
    subgraph "Detection"
        CHECK["changed_tick > last_run?"]
        RESULT["5 > 3 = true â†’ Changed!"]
    end
    
    T1 --> ADDED
    T5 --> CHANGED
    SS --> CHECK
    CHANGED --> CHECK
    CHECK --> RESULT
                </div>
            </div>

            <!-- Diagram 16: Game Loop -->
            <div class="diagram-container hidden" id="diagram-16">
                <h2>ğŸ® Game Loop: Complete Frame Flow</h2>
                <p>The complete flow of a single game frame from start to finish.</p>
                <div class="mermaid">
flowchart TB
    START[Frame Start]
    
    START --> TIME[Update Time]
    TIME --> FIRST[Stage.First]
    
    FIRST --> INPUT[Clear Input State]
    INPUT --> PREUPDATE[Stage.PreUpdate]
    
    PREUPDATE --> PINPUT[Process Player Input]
    PINPUT --> SHOOT[Handle Shooting]
    SHOOT --> UPDATE[Stage.Update]
    
    UPDATE --> AI[Run AI Systems]
    AI --> MOVE[Apply Movement]
    MOVE --> PHYSICS[Physics Updates]
    PHYSICS --> VISUALS[Update Visuals]
    VISUALS --> POSTUPDATE[Stage.PostUpdate]
    
    POSTUPDATE --> LIFETIME[Despawn Expired]
    LIFETIME --> COLLISION[Handle Collisions]
    COLLISION --> EVENTS[Process Events]
    EVENTS --> SPAWN[Spawn Enemies]
    SPAWN --> LAST[Stage.Last]
    
    LAST --> RENDER[Render Frame]
    RENDER --> UI[Update UI]
    UI --> EVTBUF[Swap Event Buffers]
    EVTBUF --> COMMANDS[Apply Commands]
    
    COMMANDS --> END[Frame End]
    END -->|Next Frame| START
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>ECS Architecture Documentation | Version 1.0 | Last Updated: January 1, 2026</p>
    </div>

    <script>
        // Initialize Mermaid with startOnLoad disabled
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            themeVariables: {
                primaryColor: '#00d9ff',
                primaryTextColor: '#000',
                primaryBorderColor: '#00d9ff',
                lineColor: '#00d9ff',
                secondaryColor: '#1e1e2e',
                tertiaryColor: '#2d2d44'
            }
        });

        // Navigation function
        function showDiagram(index) {
            // Hide all diagrams
            const containers = document.querySelectorAll('.diagram-container');
            containers.forEach(container => {
                container.classList.add('hidden');
            });

            // Show selected diagram
            const selected = document.getElementById(`diagram-${index}`);
            if (selected) {
                selected.classList.remove('hidden');
                selected.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            // Update active nav item
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // Initialize: render all diagrams first, then hide non-active ones
        window.addEventListener('load', async () => {
            // Make all containers visible but off-screen for rendering
            const containers = document.querySelectorAll('.diagram-container');
            containers.forEach(container => {
                container.classList.remove('hidden');
                container.classList.add('rendering');
            });

            // Render all mermaid diagrams
            try {
                await mermaid.run({
                    nodes: document.querySelectorAll('.mermaid')
                });
            } catch (e) {
                console.log('Mermaid rendering complete');
            }

            // Now hide all and show only the first
            containers.forEach(container => {
                container.classList.remove('rendering');
                container.classList.add('hidden');
            });

            // Show first diagram
            showDiagram(0);
        });
    </script>
</body>
</html>
